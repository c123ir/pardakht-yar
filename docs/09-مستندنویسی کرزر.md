# داکیومنت اجرایی توسعه سیستم پرداخت‌یار

<div dir="rtl">

## مقدمه

این داکیومنت اجرایی با هدف تبدیل «مستندات جامع توسعه سیستم پرداخت‌یار» به یک برنامه عملیاتی تهیه شده است. براساس بررسی کد موجود و نیازمندی‌های مستند شده، این برنامه اجرایی مراحل دقیق، زمان‌بندی، و مسیر پیاده‌سازی هر بخش را مشخص می‌کند.

## فازهای توسعه

توسعه سیستم پرداخت‌یار در چهار فاز اصلی انجام خواهد شد:

1. **بازطراحی و توسعه ساختار پایه** (۶ هفته)
2. **مدیریت امنیت و دسترسی‌ها** (۴ هفته)
3. **سیستم مدیریت و تحویل کارها** (۶ هفته)
4. **یکپارچه‌سازی و بهبود کیفیت** (۳ هفته)

## فاز اول: بازطراحی و توسعه ساختار پایه (۶ هفته)

### هفته ۱-۲: ارتقای فرم درخواست پرداخت به سیستم داینامیک (بخش اول)

#### روز ۱-۲: بازطراحی پایگاه داده

1. **ایجاد جداول جدید برای نوع درخواست‌ها**:
   ```sql
   CREATE TABLE request_types (
     id SERIAL PRIMARY KEY,
     name VARCHAR(100) NOT NULL,
     description TEXT,
     is_active BOOLEAN DEFAULT true,
     field_config JSONB NOT NULL,
     created_by INTEGER NOT NULL REFERENCES users(id),
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   ```

2. **تطبیق و گسترش جدول موجود payments به requests**:
   ```sql
   -- ابتدا ایجاد جدول جدید
   CREATE TABLE requests (
     id SERIAL PRIMARY KEY,
     request_type_id INTEGER NOT NULL REFERENCES request_types(id),
     title VARCHAR(200) NOT NULL,
     description TEXT,
     amount NUMERIC(15, 2),
     effective_date DATE,
     beneficiary_name VARCHAR(100),
     beneficiary_phone VARCHAR(20),
     contact_id INTEGER REFERENCES contacts(id),
     group_id INTEGER REFERENCES groups(id),
     status VARCHAR(20) NOT NULL,
     created_by INTEGER NOT NULL REFERENCES users(id),
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   
   -- انتقال داده‌ها از جدول قبلی
   INSERT INTO requests (
     id, title, description, amount, effective_date, 
     beneficiary_name, beneficiary_phone, contact_id, 
     group_id, status, created_by, created_at, updated_at
   )
   SELECT 
     id, title, description, amount, effective_date, 
     beneficiary_name, beneficiary_phone, contact_id, 
     group_id, status, creator_id, created_at, updated_at
   FROM payment_requests;
   ```

3. **اصلاح مدل‌های Prisma و تولید مجدد کلاینت**:
   - اضافه کردن مدل‌های جدید به فایل schema.prisma
   - اجرای دستور `npx prisma generate`
   - ایجاد مهاجرت با `npx prisma migrate dev`

#### روز ۳-۵: پیاده‌سازی بک‌اند نوع درخواست‌ها

1. **ایجاد مدل‌های TypeScript**:
   ```typescript
   // مدل نوع درخواست
   interface RequestType {
     id: number;
     name: string;
     description: string;
     isActive: boolean;
     fieldConfig: FieldConfig;
     createdBy: number;
     createdAt: Date;
     updatedAt: Date;
   }

   // تنظیمات فیلدها
   interface FieldConfig {
     title: FieldSetting;
     description: FieldSetting;
     amount: FieldSetting;
     effectiveDate: FieldSetting;
     beneficiaryName: FieldSetting;
     beneficiaryPhone: FieldSetting;
     contactId: FieldSetting;
     groupId: FieldSetting;
   }

   // تنظیمات هر فیلد
   interface FieldSetting {
     enabled: boolean;
     required: boolean;
     label: string;
   }
   ```

2. **ایجاد API های مدیریت نوع درخواست**:
   - ایجاد کنترلر `requestTypeController.ts`
   - پیاده‌سازی متدهای CRUD
   - اضافه کردن به `routes/index.ts`

3. **اعتبارسنجی پویا برای درخواست‌ها**:
   - بازنویسی میدل‌ور validator برای پشتیبانی از اعتبارسنجی داینامیک
   - ایجاد تابع تولیدکننده طرح اعتبارسنجی Joi براساس تنظیمات فیلد

#### روز ۶-۱۰: پیاده‌سازی فرانت‌اند نوع درخواست‌ها

1. **ایجاد صفحه مدیریت انواع درخواست**:
   ```typescript
   // src/pages/RequestTypes/RequestTypesPage.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, Button, Typography, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow } from '@mui/material';
   import { Add as AddIcon } from '@mui/icons-material';
   import { useRequestTypes } from '../../hooks/useRequestTypes';
   
   const RequestTypesPage: React.FC = () => {
     const { requestTypes, loading, fetchRequestTypes } = useRequestTypes();
     
     useEffect(() => {
       fetchRequestTypes();
     }, []);
     
     // JSX برای نمایش صفحه
   };
   ```

2. **ایجاد فرم تنظیم نوع درخواست**:
   - ایجاد کامپوننت `RequestTypeForm.tsx` با React Hook Form
   - امکان تنظیم عنوان و فعال/غیرفعال بودن فیلدها
   - قابلیت اعمال اجباری بودن فیلدها

3. **ایجاد هوک و سرویس‌های مورد نیاز**:
   - ایجاد `useRequestTypes.ts` برای مدیریت حالت و عملیات‌های API
   - ایجاد `requestTypeService.ts` برای تعامل با API

### هفته ۳-۴: ارتقای فرم درخواست پرداخت به سیستم داینامیک (بخش دوم)

#### روز ۱-۵: پیاده‌سازی بک‌اند درخواست‌ها

1. **بازنویسی کنترلر پرداخت‌ها به درخواست‌ها**:
   - ایجاد فایل جدید `requestController.ts`
   - اصلاح متدهای CRUD برای پشتیبانی از نوع درخواست
   - بازنویسی روتر‌ها

2. **اعتبارسنجی داینامیک درخواست‌ها**:
   ```typescript
   export const validateRequest = async (req: Request, res: Response, next: NextFunction) => {
     try {
       const { request_type_id } = req.body;
       
       // دریافت نوع درخواست و تنظیمات فیلدها
       const requestType = await prisma.requestType.findUnique({
         where: { id: request_type_id }
       });
       
       if (!requestType) {
         return res.status(400).json({ 
           success: false, 
           message: 'نوع درخواست معتبر نیست' 
         });
       }
       
       // ایجاد طرح اعتبارسنجی پویا براساس تنظیمات فیلدها
       const validationSchema = createDynamicValidationSchema(requestType.fieldConfig);
       
       // اعتبارسنجی درخواست
       await validationSchema.validateAsync(req.body, { abortEarly: false });
       
       next();
     } catch (error) {
       // مدیریت خطاهای اعتبارسنجی
     }
   };
   ```

3. **بازنویسی API های موجود**:
   - حفظ سازگاری با API قبلی برای پشتیبانی از کارکردهای موجود
   - افزودن endpoint های جدید

#### روز ۶-۱۰: پیاده‌سازی فرانت‌اند فرم داینامیک

1. **کامپوننت فرم داینامیک**:
   ```typescript
   // src/components/DynamicRequestForm.tsx
   import React, { useState, useEffect } from 'react';
   import { useForm, Controller } from 'react-hook-form';
   import { Box, Grid, TextField, Button, CircularProgress } from '@mui/material';
   
   interface DynamicRequestFormProps {
     requestTypeId: number;
     initialValues?: any;
     onSubmit: (data: any) => void;
   }
   
   const DynamicRequestForm: React.FC<DynamicRequestFormProps> = ({
     requestTypeId,
     initialValues,
     onSubmit
   }) => {
     const [requestType, setRequestType] = useState<any>(null);
     const [loading, setLoading] = useState(false);
     
     const { control, handleSubmit, reset } = useForm({
       defaultValues: initialValues || {}
     });
     
     // لود کردن تنظیمات نوع درخواست
     useEffect(() => {
       // کد دریافت نوع درخواست
     }, [requestTypeId]);
     
     // رندر فیلدها براساس تنظیمات
     const renderFields = () => {
       // کد رندر فیلدها
     };
     
     return (
       <Box component="form" onSubmit={handleSubmit(onSubmit)}>
         {loading ? (
           <CircularProgress />
         ) : (
           <Grid container spacing={2}>
             {renderFields()}
             <Grid item xs={12}>
               <Button type="submit" variant="contained" color="primary">
                 ثبت درخواست
               </Button>
             </Grid>
           </Grid>
         )}
       </Box>
     );
   };
   ```

2. **بازنویسی صفحه ایجاد/ویرایش پرداخت**:
   - اصلاح `PaymentFormPage.tsx` برای استفاده از فرم داینامیک
   - افزودن امکان انتخاب نوع درخواست
   - حفظ سازگاری با پرداخت‌های قبلی

3. **بازنویسی صفحه لیست پرداخت‌ها**:
   - اصلاح `PaymentsPage.tsx` برای پشتیبانی از نوع درخواست
   - اضافه کردن فیلتر براساس نوع درخواست

### هفته ۵-۶: پیاده‌سازی سیستم گروه‌بندی درختی دو سطحی

#### روز ۱-۳: بازطراحی مدل داده و API گروه‌ها

1. **اصلاح جدول گروه‌ها در پایگاه داده**:
   ```sql
   ALTER TABLE groups 
   ADD COLUMN parent_id INTEGER REFERENCES groups(id),
   ADD COLUMN path VARCHAR(255),
   ADD COLUMN "order" INTEGER NOT NULL DEFAULT 0;
   
   -- تنظیم مقادیر path برای گروه‌های موجود
   UPDATE groups SET path = CONCAT('/', id, '/') WHERE path IS NULL;
   ```

2. **بازنویسی کنترلر گروه‌ها**:
   - اصلاح `groupController.ts` برای پشتیبانی از ساختار درختی
   - ایجاد متدهای جدید برای جابجایی، تغییر ترتیب و ساختار درختی

3. **ایجاد API های ساختار درختی**:
   - پیاده‌سازی endpoint جدید `GET /api/groups/tree`
   - اضافه کردن endpoint برای تغییر ترتیب `PATCH /api/groups/reorder`

#### روز ۴-۱۰: پیاده‌سازی فرانت‌اند ساختار درختی

1. **ایجاد کامپوننت نمایش ساختار درختی**:
   ```typescript
   // src/components/groups/GroupTree.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, List, ListItem, ListItemText, Collapse, IconButton } from '@mui/material';
   import { ExpandMore, ExpandLess, Add, Edit, Delete } from '@mui/icons-material';
   import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
   
   interface GroupTreeProps {
     onSelect: (groupId: number) => void;
     onDrop: (result: any) => void;
   }
   
   const GroupTree: React.FC<GroupTreeProps> = ({ onSelect, onDrop }) => {
     const [groups, setGroups] = useState<any[]>([]);
     const [expandedIds, setExpandedIds] = useState<number[]>([]);
     
     // لود کردن ساختار درختی گروه‌ها
     useEffect(() => {
       // کد دریافت ساختار درختی
     }, []);
     
     // رندر بازگشتی گروه‌ها
     const renderGroups = (parentId: number | null = null, level: number = 0) => {
       // کد رندر گروه‌ها
     };
     
     return (
       <DragDropContext onDragEnd={onDrop}>
         <Droppable droppableId="groups">
           {(provided) => (
             <List
               {...provided.droppableProps}
               ref={provided.innerRef}
             >
               {renderGroups()}
               {provided.placeholder}
             </List>
           )}
         </Droppable>
       </DragDropContext>
     );
   };
   ```

2. **صفحه مدیریت گروه‌ها**:
   - بازنویسی `GroupsPage.tsx` برای پشتیبانی از ساختار درختی
   - ایجاد فرم ویرایش گروه با قابلیت انتخاب گروه والد

3. **اصلاح صفحه پرداخت‌ها برای پشتیبانی از ساختار گروه‌بندی**:
   - اضافه کردن فیلتر براساس ساختار گروه‌ها به صفحه `PaymentsPage.tsx`
   - نمایش ساختار درختی گروه‌ها در بخش فیلتر

## فاز دوم: مدیریت امنیت و دسترسی‌ها (۴ هفته)

### هفته ۱-۲: طراحی و پیاده‌سازی جداول دسترسی سه لایه

#### روز ۱-۳: ایجاد جداول پایگاه داده و مدل‌های لازم

1. **ایجاد جداول دسترسی**:
   ```sql
   CREATE TABLE roles (
     id SERIAL PRIMARY KEY,
     name VARCHAR(50) NOT NULL UNIQUE,
     description TEXT,
     is_system BOOLEAN DEFAULT false,
     created_by INTEGER NOT NULL REFERENCES users(id),
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   
   CREATE TABLE permissions (
     id SERIAL PRIMARY KEY,
     code VARCHAR(100) NOT NULL UNIQUE,
     name VARCHAR(100) NOT NULL,
     description TEXT,
     "group" VARCHAR(50) NOT NULL
   );
   
   CREATE TABLE role_permissions (
     id SERIAL PRIMARY KEY,
     role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
     permission_id INTEGER NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
     UNIQUE(role_id, permission_id)
   );
   
   CREATE TABLE user_roles (
     id SERIAL PRIMARY KEY,
     user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
     role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
     UNIQUE(user_id, role_id)
   );
   
   CREATE TABLE user_permissions (
     id SERIAL PRIMARY KEY,
     user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
     permission_id INTEGER NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
     granted BOOLEAN NOT NULL DEFAULT true,
     UNIQUE(user_id, permission_id)
   );
   ```

2. **تعریف مجوزهای پایه سیستم**:
   ```sql
   INSERT INTO permissions (code, name, description, "group") VALUES
   -- مجوزهای کاربران
   ('users.view', 'مشاهده کاربران', 'امکان مشاهده لیست کاربران', 'users'),
   ('users.create', 'ایجاد کاربر', 'امکان ایجاد کاربر جدید', 'users'),
   ('users.edit', 'ویرایش کاربر', 'امکان ویرایش اطلاعات کاربران', 'users'),
   ('users.delete', 'حذف کاربر', 'امکان حذف کاربران', 'users'),
   
   -- مجوزهای مدیریت نقش‌ها
   ('roles.view', 'مشاهده نقش‌ها', 'امکان مشاهده لیست نقش‌ها', 'roles'),
   ('roles.create', 'ایجاد نقش', 'امکان ایجاد نقش جدید', 'roles'),
   ('roles.edit', 'ویرایش نقش', 'امکان ویرایش نقش‌ها', 'roles'),
   ('roles.delete', 'حذف نقش', 'امکان حذف نقش‌ها', 'roles'),
   
   -- مجوزهای درخواست‌ها
   ('requests.view', 'مشاهده درخواست‌ها', 'امکان مشاهده لیست درخواست‌ها', 'requests'),
   ('requests.create', 'ایجاد درخواست', 'امکان ایجاد درخواست جدید', 'requests'),
   ('requests.edit', 'ویرایش درخواست', 'امکان ویرایش درخواست‌ها', 'requests'),
   ('requests.delete', 'حذف درخواست', 'امکان حذف درخواست‌ها', 'requests'),
   ('requests.approve', 'تأیید درخواست', 'امکان تأیید درخواست‌ها', 'requests'),
   ('requests.reject', 'رد درخواست', 'امکان رد درخواست‌ها', 'requests'),
   
   -- مجوزهای گروه‌ها
   ('groups.view', 'مشاهده گروه‌ها', 'امکان مشاهده لیست گروه‌ها', 'groups'),
   ('groups.create', 'ایجاد گروه', 'امکان ایجاد گروه جدید', 'groups'),
   ('groups.edit', 'ویرایش گروه', 'امکان ویرایش گروه‌ها', 'groups'),
   ('groups.delete', 'حذف گروه', 'امکان حذف گروه‌ها', 'groups');
   ```

3. **تعریف نقش‌های پایه سیستم**:
   ```sql
   INSERT INTO roles (name, description, is_system, created_by) VALUES
   ('admin', 'مدیر سیستم', true, 1),
   ('user', 'کاربر عادی', true, 1),
   ('accountant', 'حسابدار', true, 1),
   ('manager', 'مدیر', true, 1);
   ```

#### روز ۴-۵: پیاده‌سازی API های مدیریت نقش‌ها و مجوزها

1. **ایجاد کنترلر نقش‌ها**:
   ```typescript
   // src/controllers/roleController.ts
   import { Request, Response } from 'express';
   import { PrismaClient } from '@prisma/client';
   import { ApiError } from '../middleware/error';
   
   const prisma = new PrismaClient();
   
   export const getRoles = async (req: Request, res: Response) => {
     try {
       const roles = await prisma.role.findMany({
         include: {
           rolePermissions: {
             include: {
               permission: true
             }
           }
         }
       });
       
       return res.status(200).json({
         success: true,
         data: roles
       });
     } catch (error) {
       throw new ApiError(500, 'خطا در دریافت نقش‌ها');
     }
   };
   
   // سایر متدهای CRUD برای نقش‌ها
   ```

2. **ایجاد کنترلر مجوزها**:
   ```typescript
   // src/controllers/permissionController.ts
   import { Request, Response } from 'express';
   import { PrismaClient } from '@prisma/client';
   import { ApiError } from '../middleware/error';
   
   const prisma = new PrismaClient();
   
   export const getPermissions = async (req: Request, res: Response) => {
     try {
       const permissions = await prisma.permission.findMany({
         orderBy: {
           group: 'asc'
         }
       });
       
       // گروه‌بندی مجوزها
       const groupedPermissions = permissions.reduce((acc, permission) => {
         if (!acc[permission.group]) {
           acc[permission.group] = [];
         }
         acc[permission.group].push(permission);
         return acc;
       }, {} as Record<string, any[]>);
       
       return res.status(200).json({
         success: true,
         data: groupedPermissions
       });
     } catch (error) {
       throw new ApiError(500, 'خطا در دریافت مجوزها');
     }
   };
   
   // سایر متدهای مدیریت مجوزها
   ```

3. **ایجاد API های مدیریت دسترسی کاربران**:
   - کنترلرهای اختصاص نقش به کاربر
   - کنترلرهای تنظیم مجوزهای مستقیم کاربر
   - کنترلر کپی دسترسی‌ها از یک کاربر به کاربر دیگر

#### روز ۶-۱۰: بازنویسی سیستم احراز هویت و میدل‌ور دسترسی

1. **اصلاح میدل‌ور دسترسی**:
   ```typescript
   // src/middleware/auth.ts
   import { Request, Response, NextFunction } from 'express';
   import jwt from 'jsonwebtoken';
   import { PrismaClient } from '@prisma/client';
   
   const prisma = new PrismaClient();
   
   export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
     try {
       // کد احراز هویت
     } catch (error) {
       return res.status(401).json({
         success: false,
         message: 'احراز هویت ناموفق'
       });
     }
   };
   
   export const authorize = (requiredPermissions: string[]) => {
     return async (req: Request, res: Response, next: NextFunction) => {
       try {
         if (!req.user) {
           return res.status(401).json({
             success: false,
             message: 'احراز هویت نشده اید'
           });
         }
         
         const userId = req.user.id;
         
         // دریافت مجوزهای کاربر (از طریق نقش‌ها و مجوزهای مستقیم)
         const userRolePermissions = await prisma.rolePermission.findMany({
           where: {
             role: {
               userRoles: {
                 some: {
                   userId
                 }
               }
             }
           },
           include: {
             permission: true
           }
         });
         
         const userDirectPermissions = await prisma.userPermission.findMany({
           where: {
             userId
           },
           include: {
             permission: true
           }
         });
         
         // ایجاد نقشه مجوزها
         const permissionsMap = new Map();
         
         // افزودن مجوزهای نقش‌ها
         userRolePermissions.forEach(rp => {
           permissionsMap.set(rp.permission.code, true);
         });
         
         // اعمال مجوزهای مستقیم (اولویت بالاتر)
         userDirectPermissions.forEach(up => {
           permissionsMap.set(up.permission.code, up.granted);
         });
         
         // بررسی دسترسی‌های مورد نیاز
         const hasAllPermissions = requiredPermissions.every(permission => 
           permissionsMap.get(permission) === true
         );
         
         if (!hasAllPermissions) {
           return res.status(403).json({
             success: false,
             message: 'دسترسی ندارید'
           });
         }
         
         next();
       } catch (error) {
         return res.status(500).json({
           success: false,
           message: 'خطا در بررسی دسترسی‌ها'
         });
       }
     };
   };
   ```

2. **نگهداری مجوزهای کاربر در توکن JWT**:
   - اصلاح متد ورود برای افزودن مجوزها به payload توکن
   - پیاده‌سازی متد بررسی دسترسی‌های جاری کاربر

### هفته ۳-۴: پیاده‌سازی فرانت‌اند سیستم دسترسی‌ها

#### روز ۱-۵: کامپوننت‌های مدیریت نقش‌ها و دسترسی‌ها

1. **صفحه مدیریت نقش‌ها**:
   ```typescript
   // src/pages/RolesPage.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, Button, Typography, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow } from '@mui/material';
   import { Add as AddIcon, Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';
   import { useRoles } from '../hooks/useRoles';
   
   const RolesPage: React.FC = () => {
     const { roles, loading, fetchRoles, deleteRole } = useRoles();
     const [openDialog, setOpenDialog] = useState(false);
     const [selectedRole, setSelectedRole] = useState<any>(null);
     
     useEffect(() => {
       fetchRoles();
     }, []);
     
     // JSX برای نمایش صفحه
   };
   ```

2. **کامپوننت ویرایشگر مجوزهای نقش**:
   ```typescript
   // src/components/roles/RolePermissionsEditor.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, Checkbox, FormControlLabel, Typography, Divider, Button } from '@mui/material';
   import { usePermissions } from '../../hooks/usePermissions';
   

بله، شما حق دارید. متوجه شدم که داکیومنت اجرایی ناقص است. اجازه دهید ادامه آن را کامل کنم:

<div dir="rtl">

## ادامه فاز دوم (مدیریت امنیت و دسترسی‌ها)

### هفته ۳-۴: پیاده‌سازی فرانت‌اند سیستم دسترسی‌ها (ادامه)

2. **کامپوننت ویرایشگر مجوزهای نقش** (ادامه):
   ```typescript
   // src/components/roles/RolePermissionsEditor.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, Checkbox, FormControlLabel, Typography, Divider, Button } from '@mui/material';
   import { usePermissions } from '../../hooks/usePermissions';
   
   interface RolePermissionsEditorProps {
     roleId: number;
     selectedPermissions: number[];
     onChange: (permissionIds: number[]) => void;
   }
   
   const RolePermissionsEditor: React.FC<RolePermissionsEditorProps> = ({
     roleId,
     selectedPermissions,
     onChange
   }) => {
     const { permissions, loading, fetchPermissions } = usePermissions();
     const [selected, setSelected] = useState<number[]>(selectedPermissions);
     
     useEffect(() => {
       fetchPermissions();
     }, []);
     
     const handleTogglePermission = (permissionId: number) => {
       const newSelected = selected.includes(permissionId)
         ? selected.filter(id => id !== permissionId)
         : [...selected, permissionId];
       
       setSelected(newSelected);
       onChange(newSelected);
     };
     
     const renderPermissionGroups = () => {
       if (!permissions || loading) return <div>در حال بارگذاری...</div>;
       
       return Object.entries(permissions).map(([groupName, groupPermissions]) => (
         <Box key={groupName} sx={{ mb: 2 }}>
           <Typography variant="subtitle1" fontWeight="bold">
             {getGroupTitle(groupName)}
           </Typography>
           <Divider sx={{ my: 1 }} />
           <Box sx={{ display: 'flex', flexDirection: 'column' }}>
             {groupPermissions.map(permission => (
               <FormControlLabel
                 key={permission.id}
                 control={
                   <Checkbox
                     checked={selected.includes(permission.id)}
                     onChange={() => handleTogglePermission(permission.id)}
                   />
                 }
                 label={permission.name}
               />
             ))}
           </Box>
         </Box>
       ));
     };
     
     const getGroupTitle = (groupCode: string) => {
       const groupTitles: Record<string, string> = {
         users: 'مدیریت کاربران',
         roles: 'مدیریت نقش‌ها',
         requests: 'مدیریت درخواست‌ها',
         groups: 'مدیریت گروه‌ها'
       };
       
       return groupTitles[groupCode] || groupCode;
     };
     
     return (
       <Box>
         {renderPermissionGroups()}
       </Box>
     );
   };
   ```

3. **کامپوننت مدیریت دسترسی‌های کاربر**:
   ```typescript
   // src/components/users/UserPermissionsTab.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, Tabs, Tab, Button, Chip, Typography, Divider } from '@mui/material';
   import { useUserPermissions } from '../../hooks/useUserPermissions';
   import { useRoles } from '../../hooks/useRoles';
   
   interface UserPermissionsTabProps {
     userId: number;
   }
   
   const UserPermissionsTab: React.FC<UserPermissionsTabProps> = ({ userId }) => {
     const [tabIndex, setTabIndex] = useState(0);
     const { userRoles, userPermissions, loading, fetchUserRoles, fetchUserPermissions, assignRole, removeRole, updateDirectPermissions } = useUserPermissions(userId);
     const { roles, loading: rolesLoading, fetchRoles } = useRoles();
     
     useEffect(() => {
       fetchUserRoles();
       fetchUserPermissions();
       fetchRoles();
     }, [userId]);
     
     const handleChangeTab = (event: React.SyntheticEvent, newValue: number) => {
       setTabIndex(newValue);
     };
     
     return (
       <Box>
         <Tabs value={tabIndex} onChange={handleChangeTab}>
           <Tab label="نقش‌ها" />
           <Tab label="دسترسی‌های مستقیم" />
           <Tab label="کپی دسترسی‌ها" />
         </Tabs>
         
         <Box sx={{ p: 2 }}>
           {tabIndex === 0 && <UserRolesManager userId={userId} userRoles={userRoles} availableRoles={roles} onAssign={assignRole} onRemove={removeRole} />}
           {tabIndex === 1 && <UserDirectPermissions userId={userId} userPermissions={userPermissions} onUpdate={updateDirectPermissions} />}
           {tabIndex === 2 && <CopyPermissionsForm userId={userId} />}
         </Box>
       </Box>
     );
   };
   ```

#### روز ۶-۱۰: پیاده‌سازی لایه امنیتی در فرانت‌اند

1. **کامپوننت‌های حفاظت شده**:
   ```typescript
   // src/components/common/ProtectedRoute.tsx
   import React from 'react';
   import { Navigate } from 'react-router-dom';
   import { useAuth } from '../../contexts/AuthContext';
   import AccessDenied from './AccessDenied';
   
   interface ProtectedRouteProps {
     permission: string;
     redirectTo?: string;
     fallback?: React.ReactNode;
     children: React.ReactNode;
   }
   
   const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
     permission,
     redirectTo = '/login',
     fallback = <AccessDenied />,
     children
   }) => {
     const { isAuthenticated, hasPermission } = useAuth();
     
     if (!isAuthenticated) {
       return <Navigate to={redirectTo} />;
     }
     
     if (!hasPermission(permission)) {
       return <>{fallback}</>;
     }
     
     return <>{children}</>;
   };
   ```

2. **اصلاح کانتکست احراز هویت**:
   ```typescript
   // src/contexts/AuthContext.tsx
   import React, { createContext, useState, useContext, useEffect } from 'react';
   import api from '../services/api';
   import { jwtDecode } from 'jwt-decode';
   
   interface AuthContextType {
     isAuthenticated: boolean;
     user: any;
     permissions: string[];
     login: (email: string, password: string) => Promise<void>;
     logout: () => void;
     hasPermission: (permission: string) => boolean;
   }
   
   const AuthContext = createContext<AuthContextType>({} as AuthContextType);
   
   export const useAuth = () => useContext(AuthContext);
   
   export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
     const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
     const [user, setUser] = useState<any>(null);
     const [permissions, setPermissions] = useState<string[]>([]);
     const [loading, setLoading] = useState<boolean>(true);
     
     useEffect(() => {
       const checkAuth = async () => {
         const token = localStorage.getItem('token');
         if (token) {
           try {
             const decoded = jwtDecode(token);
             setUser(decoded.user);
             setPermissions(decoded.permissions || []);
             setIsAuthenticated(true);
           } catch (error) {
             localStorage.removeItem('token');
           }
         }
         setLoading(false);
       };
       
       checkAuth();
     }, []);
     
     const login = async (email: string, password: string) => {
       const response = await api.post('/auth/login', { email, password });
       const { token, user, permissions } = response.data;
       
       localStorage.setItem('token', token);
       setUser(user);
       setPermissions(permissions);
       setIsAuthenticated(true);
     };
     
     const logout = () => {
       localStorage.removeItem('token');
       setUser(null);
       setPermissions([]);
       setIsAuthenticated(false);
     };
     
     const hasPermission = (permission: string) => {
       return permissions.includes(permission);
     };
     
     return (
       <AuthContext.Provider
         value={{
           isAuthenticated,
           user,
           permissions,
           login,
           logout,
           hasPermission
         }}
       >
         {!loading && children}
       </AuthContext.Provider>
     );
   };
   ```

3. **پیاده‌سازی هوک مدیریت دسترسی‌ها**:
   ```typescript
   // src/hooks/usePermission.ts
   import { useState } from 'react';
   import api from '../services/api';
   
   export const usePermissions = () => {
     const [permissions, setPermissions] = useState<any>(null);
     const [loading, setLoading] = useState<boolean>(false);
     const [error, setError] = useState<string | null>(null);
     
     const fetchPermissions = async () => {
       try {
         setLoading(true);
         const response = await api.get('/permissions');
         setPermissions(response.data.data);
       } catch (err: any) {
         setError(err.message || 'خطا در دریافت مجوزها');
       } finally {
         setLoading(false);
       }
     };
     
     const checkPermission = async (code: string) => {
       try {
         const response = await api.get(`/permissions/check?code=${code}`);
         return response.data.hasPermission;
       } catch (err) {
         return false;
       }
     };
     
     return {
       permissions,
       loading,
       error,
       fetchPermissions,
       checkPermission
     };
   };
   ```

## فاز سوم: سیستم مدیریت و تحویل کارها (۶ هفته)

### هفته ۱-۲: طراحی و پیاده‌سازی پایگاه داده و API های اصلی

#### روز ۱-۳: ایجاد جداول پایگاه داده و مدل‌های اصلی

1. **ایجاد جداول مدیریت کارها**:
   ```sql
   CREATE TABLE tasks (
     id SERIAL PRIMARY KEY,
     title VARCHAR(200) NOT NULL,
     description TEXT,
     creator_id INTEGER NOT NULL REFERENCES users(id),
     assignee_id INTEGER NOT NULL REFERENCES users(id),
     secondary_assignee_id INTEGER REFERENCES users(id),
     due_date DATE NOT NULL,
     reminder_date_time TIMESTAMP WITH TIME ZONE,
     status VARCHAR(20) NOT NULL DEFAULT 'TODO',
     priority VARCHAR(20) NOT NULL DEFAULT 'MEDIUM',
     completion_report TEXT,
     primary_completed BOOLEAN NOT NULL DEFAULT false,
     secondary_completed BOOLEAN NOT NULL DEFAULT false,
     creator_approved BOOLEAN NOT NULL DEFAULT false,
     performance_rating INTEGER CHECK (performance_rating BETWEEN 1 AND 5),
     send_reminder BOOLEAN NOT NULL DEFAULT false,
     reminder_text TEXT,
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   
   CREATE TABLE task_attachments (
     id SERIAL PRIMARY KEY,
     task_id INTEGER NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
     file_path VARCHAR(500) NOT NULL,
     file_type VARCHAR(50) NOT NULL,
     file_name VARCHAR(255) NOT NULL,
     uploaded_by INTEGER NOT NULL REFERENCES users(id),
     uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   
   CREATE TABLE task_activities (
     id SERIAL PRIMARY KEY,
     task_id INTEGER NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
     user_id INTEGER NOT NULL REFERENCES users(id),
     action VARCHAR(50) NOT NULL,
     details JSONB,
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   
   CREATE TABLE task_reminders (
     id SERIAL PRIMARY KEY,
     task_id INTEGER NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
     reminder_type VARCHAR(20) NOT NULL,
     reminder_text TEXT,
     scheduled_date_time TIMESTAMP WITH TIME ZONE NOT NULL,
     sent_at TIMESTAMP WITH TIME ZONE,
     status VARCHAR(20) NOT NULL DEFAULT 'scheduled',
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   );
   ```

2. **مدل‌های TypeScript**:
   ```typescript
   // src/types/task.types.ts
   export enum TaskStatus {
     TODO = 'TODO',
     IN_PROGRESS = 'IN_PROGRESS',
     UNDER_REVIEW = 'UNDER_REVIEW',
     COMPLETED = 'COMPLETED',
     CANCELED = 'CANCELED'
   }
   
   export enum TaskPriority {
     LOW = 'LOW',
     MEDIUM = 'MEDIUM',
     HIGH = 'HIGH',
     URGENT = 'URGENT'
   }
   
   export interface Task {
     id: number;
     title: string;
     description: string;
     creatorId: number;
     assigneeId: number;
     secondaryAssigneeId?: number;
     dueDate: string;
     reminderDateTime?: string;
     status: TaskStatus;
     priority: TaskPriority;
     completionReport?: string;
     primaryCompleted: boolean;
     secondaryCompleted: boolean;
     creatorApproved: boolean;
     performanceRating?: number;
     sendReminder: boolean;
     reminderText?: string;
     createdAt: string;
     updatedAt: string;
     
     // Relations
     creator?: {
       id: number;
       fullName: string;
     };
     assignee?: {
       id: number;
       fullName: string;
     };
     secondaryAssignee?: {
       id: number;
       fullName: string;
     };
   }
   
   export interface TaskAttachment {
     id: number;
     taskId: number;
     filePath: string;
     fileType: string;
     fileName: string;
     uploadedBy: number;
     uploadedAt: string;
   }
   
   export interface TaskActivity {
     id: number;
     taskId: number;
     userId: number;
     action: string;
     details: any;
     createdAt: string;
     
     // Relations
     user?: {
       id: number;
       fullName: string;
     };
   }
   ```

#### روز ۴-۱۰: پیاده‌سازی API های مدیریت کارها

1. **کنترلر کارها**:
   ```typescript
   // src/controllers/taskController.ts
   import { Request, Response } from 'express';
   import { PrismaClient } from '@prisma/client';
   import { ApiError } from '../middleware/error';
   
   const prisma = new PrismaClient();
   
   // دریافت لیست کارها
   export const getTasks = async (req: Request, res: Response) => {
     try {
       const { 
         page = 1, 
         limit = 10, 
         status, 
         assignee,
         priority,
         search = ''
       } = req.query;
       
       const pageNumber = Number(page);
       const limitNumber = Number(limit);
       const skip = (pageNumber - 1) * limitNumber;
       
       // ساخت شروط جستجو
       const whereConditions: any = {};
       
       if (status) {
         whereConditions.status = status;
       }
       
       if (assignee) {
         whereConditions.assigneeId = Number(assignee);
       }
       
       if (priority) {
         whereConditions.priority = priority;
       }
       
       if (search) {
         whereConditions.OR = [
           { title: { contains: search as string, mode: 'insensitive' } },
           { description: { contains: search as string, mode: 'insensitive' } }
         ];
       }
       
       const [tasks, totalItems] = await Promise.all([
         prisma.task.findMany({
           where: whereConditions,
           skip,
           take: limitNumber,
           orderBy: {
             createdAt: 'desc'
           },
           include: {
             creator: {
               select: {
                 id: true,
                 fullName: true
               }
             },
             assignee: {
               select: {
                 id: true,
                 fullName: true
               }
             },
             secondaryAssignee: {
               select: {
                 id: true,
                 fullName: true
               }
             }
           }
         }),
         prisma.task.count({
           where: whereConditions
         })
       ]);
       
       return res.status(200).json({
         success: true,
         data: tasks,
         pagination: {
           page: pageNumber,
           limit: limitNumber,
           totalItems,
           totalPages: Math.ceil(totalItems / limitNumber)
         }
       });
     } catch (error) {
       throw new ApiError(500, 'خطا در دریافت لیست کارها');
     }
   };
   
   // ایجاد کار جدید
   export const createTask = async (req: Request, res: Response) => {
     try {
       const {
         title,
         description,
         assigneeId,
         secondaryAssigneeId,
         dueDate,
         reminderDateTime,
         priority,
         sendReminder,
         reminderText
       } = req.body;
       
       const creatorId = req.user.id;
       
       const task = await prisma.task.create({
         data: {
           title,
           description,
           creatorId,
           assigneeId,
           secondaryAssigneeId,
           dueDate,
           reminderDateTime,
           status: 'TODO',
           priority: priority || 'MEDIUM',
           primaryCompleted: false,
           secondaryCompleted: false,
           creatorApproved: false,
           sendReminder: sendReminder || false,
           reminderText
         }
       });
       
       // ثبت فعالیت ایجاد کار
       await prisma.taskActivity.create({
         data: {
           taskId: task.id,
           userId: creatorId,
           action: 'create',
           details: { message: 'کار جدید ایجاد شد' }
         }
       });
       
       // ایجاد یادآوری در صورت نیاز
       if (sendReminder && reminderDateTime) {
         await prisma.taskReminder.create({
           data: {
             taskId: task.id,
             reminderType: 'first',
             reminderText: reminderText || `یادآوری: کار "${title}" نزدیک به سررسید است`,
             scheduledDateTime: reminderDateTime,
             status: 'scheduled'
           }
         });
       }
       
       return res.status(201).json({
         success: true,
         data: task
       });
     } catch (error) {
       throw new ApiError(500, 'خطا در ایجاد کار جدید');
     }
   };
   
   // سایر متدهای CRUD و مدیریت وضعیت کارها
   ```

2. **کنترلر پیوست‌های کار**:
   ```typescript
   // src/controllers/taskAttachmentController.ts
   import { Request, Response } from 'express';
   import { PrismaClient } from '@prisma/client';
   import { ApiError } from '../middleware/error';
   import path from 'path';
   import fs from 'fs';
   
   const prisma = new PrismaClient();
   
   // آپلود پیوست جدید
   export const uploadTaskAttachment = async (req: Request, res: Response) => {
     try {
       if (!req.file) {
         return res.status(400).json({
           success: false,
           message: 'فایلی آپلود نشده است'
         });
       }
       
       const { taskId } = req.params;
       const uploaderId = req.user.id;
       
       // بررسی وجود کار
       const task = await prisma.task.findUnique({
         where: {
           id: Number(taskId)
         }
       });
       
       if (!task) {
         return res.status(404).json({
           success: false,
           message: 'کار مورد نظر یافت نشد'
         });
       }
       
       // تعیین نوع فایل
       let fileType = 'document';
       if (req.file.mimetype.startsWith('image')) {
         fileType = 'image';
       } else if (req.file.mimetype.startsWith('audio')) {
         fileType = 'audio';
       }
       
       // ایجاد رکورد پیوست
       const attachment = await prisma.taskAttachment.create({
         data: {
           taskId: Number(taskId),
           filePath: req.file.path,
           fileType,
           fileName: req.file.originalname,
           uploadedBy: uploaderId
         }
       });
       
       // ثبت فعالیت آپلود پیوست
       await prisma.taskActivity.create({
         data: {
           taskId: Number(taskId),
           userId: uploaderId,
           action: 'attachment_upload',
           details: { attachmentId: attachment.id, fileName: req.file.originalname }
         }
       });
       
       return res.status(201).json({
         success: true,
         data: attachment
       });
     } catch (error) {
       throw new ApiError(500, 'خطا در آپلود پیوست');
     }
   };
   
   // سایر متدهای مدیریت پیوست‌ها
   ```

3. **مدیریت یادآوری‌ها**:
   ```typescript
   // src/services/reminderService.ts
   import { PrismaClient } from '@prisma/client';
   import { sendSMS } from './smsService';
   import logger from '../config/logger';
   
   const prisma = new PrismaClient();
   
   export const processReminders = async () => {
     try {
       // دریافت یادآوری‌های زمان‌بندی شده که زمان ارسال آنها فرا رسیده
       const reminders = await prisma.taskReminder.findMany({
         where: {
           status: 'scheduled',
           scheduledDateTime: {
             lte: new Date()
           }
         },
         include: {
           task: {
             include: {
               assignee: true
             }
           }
         }
       });
       
       for (const reminder of reminders) {
         try {
           // ارسال پیامک به مسئول کار
           if (reminder.task.assignee.phone) {
             await sendSMS(
               reminder.task.assignee.phone,
               reminder.reminderText || `یادآوری: کار "${reminder.task.title}" نزدیک به سررسید است`
             );
             
             // به‌روزرسانی وضعیت یادآوری
             await prisma.taskReminder.update({
               where: {
                 id: reminder.id
               },
               data: {
                 status: 'sent',
                 sentAt: new Date()
               }
             });
             
             // ثبت فعالیت ارسال یادآوری
             await prisma.taskActivity.create({
               data: {
                 taskId: reminder.taskId,
                 userId: 1, // کاربر سیستم
                 action: 'reminder_sent',
                 details: { reminderId: reminder.id, reminderType: reminder.reminderType }
               }
             });
           }
         } catch (error) {
           logger.error(`خطا در ارسال یادآوری ${reminder.id}:`, error);
           
           // ثبت خطا در ارسال یادآوری
           await prisma.taskReminder.update({
             where: {
               id: reminder.id
             },
             data: {
               status: 'failed'
             }
           });
         }
       }
     } catch (error) {
       logger.error('خطا در پردازش یادآوری‌ها:', error);
     }
   };
   ```

### هفته ۳-۶: پیاده‌سازی فرانت‌اند مدیریت کارها

#### روز ۱-۵: ایجاد کامپوننت‌های اصلی کارها

1. **صفحه داشبورد کارها**:
   ```typescript
   // src/pages/TasksDashboardPage.tsx
   import React, { useState, useEffect } from 'react';
   import { Box, Grid, Typography, Paper, Tabs, Tab, Chip, Button } from '@mui/material';
   import { Add as AddIcon } from '@mui/icons-material';
   import { useTasks } from '../hooks/useTasks';
   import { TaskStatus } from '../types/task.types';
   import TasksList from '../components/tasks/TasksList';
   import TaskForm from '../components/tasks/TaskForm';
   
   const TasksDashboardPage: React.FC = () => {
     const [tabIndex, setTabIndex] = useState(0);
     const [openTaskForm, setOpenTaskForm] = useState(false);
     const { tasks, loading, error, fetchTasks } = useTasks();
     
     useEffect(() => {
       fetchTasks({
         status: getStatusFromTabIndex(tabIndex)
       });
     }, [tabIndex]);
     
     const handleChangeTab = (event: React.SyntheticEvent, newValue: number) => {
       setTabIndex(newValue);
     };
     
     const getStatusFromTabIndex = (index: number): TaskStatus | undefined => {
       switch (index) {
         case 0: return undefined; // همه
         case 1: return TaskStatus.TODO;
         case 2: return TaskStatus.IN_PROGRESS;
         case 3: return TaskStatus.UNDER_REVIEW;
         case 4: return TaskStatus.COMPLETED;
         default: return undefined;
       }
     };
     
     const getTaskCountByStatus = (status: TaskStatus): number => {
       return tasks.filter(task => task.status === status).length;
     };
     
     return (
       <Box p={3}>
         <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
           <Typography variant="h5">مدیریت کارها</Typography>
           <Button
             variant="contained"
             startIcon={<AddIcon />}
             onClick={() => setOpenTaskForm(true)}
           >
             کار جدید
           </Button>
         </Box>
         
         <Grid container spacing={3} mb={3}>
           <Grid item xs={12} md={3}>
             <Paper sx={{ p: 2 }}>
               <Typography variant="h6" gutterBottom>
                 کارهای در انتظار
               </Typography>
               <Typography variant="h4">
                 {getTaskCountByStatus(TaskStatus.TODO)}
               </Typography>
             </Paper>
           </Grid>
           <Grid item xs={12} md={3}>
             <Paper sx={{ p: 2 }}>
               <Typography variant="h6" gutterBottom>
                 در حال انجام
               </Typography>
               <Typography variant="h4">
                 {getTaskCountByStatus(TaskStatus.IN_PROGRESS)}
               </Typography>
             </Paper>
           </Grid>
           <Grid item xs={12} md={3}>
             <Paper sx={{ p: 2 }}>
               <Typography variant="h6" gutterBottom>
                 در حال بررسی
               </Typography>
               <Typography variant="h4">
                 {getTaskCountByStatus(TaskStatus.UNDER_REVIEW)}
               </Typography>
             </Paper>
           </Grid>
           <Grid item xs={12} md={3}>
             <Paper sx={{ p: 2 }}>
               <Typography variant="h6" gutterBottom>
                 تکمیل شده
               </Typography>
               <Typography variant="h4">
                 {getTaskCountByStatus(TaskStatus.COMPLETED)}
               </Typography>
             </Paper>
           </Grid>
         </Grid>
         
         <Paper>
           <Tabs value={tabIndex} onChange={handleChangeTab}>
             <Tab label="همه" />
             <Tab 
               label={
                 <Box display="flex" alignItems="center">
                   در انتظار
                   <Chip 
                     size="small" 
                     label={getTaskCountByStatus(TaskStatus.TODO)} 
                     sx={{ ml: 1 }} 
                   />
                 </Box>
               } 
             />
             <Tab 
               label={
                 <Box display="flex" alignItems="center">
                   در حال انجام
                   <Chip 
                     size="small" 
                     label={getTaskCountByStatus(TaskStatus.IN_PROGRESS)} 
                     sx={{ ml: 1 }} 
                   />
                 </Box>
               } 
             />
             <Tab 
               label={
                 <Box display="flex" alignItems="center">
                   در حال بررسی
                   <Chip 
                     size="small" 
                     label={getTaskCountByStatus(TaskStatus.UNDER_REVIEW)} 
                     sx={{ ml: 1 }}



